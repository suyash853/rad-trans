# -*- coding: utf-8 -*-
"""run_RATRAN.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1eDGVaogHpn2w24RSe--SgRYA4hs5gazb
"""

from scipy import constants
import numpy as np
from scipy import optimize 
import os
from astropy.io import fits
import time
from matplotlib import colors
import matplotlib.pyplot as plt

"""Velocity Profiles :"""

def shu_v_profile(x_array,a,m0=.975):
  """creates and returns numpy array of velocity profile based on Shu(1977).
  
  Inputs:
  x_array: array of x values, where x for a given distance r is given by x=r/at. a= isothermal speed of sound in medium, t= time since start of collapse
  a: isothermal sound speed in m/s
  m0: free parameter taken to be 0.975 generally
  """  
    v_array=[]
    
    shu_x= np.linspace(0.05,1.00,20)
    shu_v= [-5.44,-3.47,-2.58,-2.05,-1.68,-1.40,-1.18,-1.01,
        -.861, -.735,-.625,-.528,-.442,-.363,-.291,-.225,
        -.163,-.106,-.051,0]

    def func(x,a0,a1,a2,a3,a4):
        return a0 + a1*x + a2*x**2 + a3*x**-.5+ a4*np.log(x)     
    
    t= optimize.curve_fit(func, shu_x, shu_v)
    
    for x in x_array:
        if x==0:
            v_array.append(0)
        elif x<.05:
           v_array.append(-a*(2*m0/x)**.5)
        elif x>=1:
            v_array.append(0)
        else:
           v_array.append(a*func(x,t[0][0], t[0][1], t[0][2], t[0][3], t[0][4])) 
           
    return np.array(v_array)/constants.kilo   

def static_v(x_array,a,t,m0=.975):
  """creates and returns numpy array of velocity profile of static cloud.
  
  Inputs:
  x_array: array of x values, where x for a given distance r is given by x=r/at. a= free parameter, t= age
  a: free parameter
  m0: free parameter taken to be 0.975 generally
  """ 
    return np.zeros(len(x_array))

def const_v(x_array,a,t):
  """creates and returns numpy array of velocity profile of static cloud.
  
  Inputs:
  x_array: array of x values, where x for a given distance r is given by x=r/at. a= free parameter used to fix velocity, t= age
  a: free parameter
  m0: free parameter taken to be 0.975 generally
  """ 
    vsys= x_array[-1]*a/10
    
    return vsys*np.ones(len(x_array))

def v_exp(x_array,a,t, ve=13):
"""creates and returns numpy array of velocity profile of exponentially increasing velocity.
  
  Inputs:
  x_array: array of x values, where x for a given distance r is given by x=r/at. a= isothermal sound speed inside the photodissociative region , t= time since start of collapse
  a: isothermal sound speed inside the photodissociative region
  m0: free parameter taken to be 0.975 generally
  """ 
    r_arr=  x_array*a*t
    v= ve*(r_arr[1:]/r_arr[-1])**(-.75)
    return np.concatenate((np.array([v[0]]),v))

"""Density Profiles"""

def shu_nu_profile(x_array, a, t, m0=.975):
  """creates and returns numpy array of density profile based on Shu(1977).
  
  Inputs:
  x_array: array of x values, where x for a given distance r is given by x=r/at. a= isothermal speed of sound in medium, t= time since start of collapse.
  a: isothermal sound speed in m/s
  t: time since start of the collapse in seconds
  m0: free parameter taken to be 0.975 generally
  """ 
    fact=500*constants.N_A*constants.centi**3/(4*constants.pi*constants.G*t**2)
    
    shu_x= np.linspace(0.05,1.00,20)
    shu_nu= np.array([71.5,27.8,16.4,11.5,8.76,7.09,5.95,5.14,4.52,4.04,3.66,3.35,3.08,2.86,2.67,2.5,2.35,2.22,2.1, 2])
    
    def func(x,a0,a1,a2,a3,a4):
        return a0 + a1/x + a2/x**2 + a3*x**-.5+ a4*np.exp(-x)    
    
    t= optimize.curve_fit(func, shu_x, shu_nu)
    nu_array=[]
    for x in x_array:
        if x>1:
            nu_array.append(2*fact/(x**2))
        elif x==0:
            nu_array.append(0)
        elif x<.05:
            nu_array.append(fact*((m0/(2*x**3))**.5))
        else:
            nu_array.append(fact*func(x,t[0][0], t[0][1], t[0][2], t[0][3], t[0][4]))
            
    return np.array(nu_array)  

def const_nu(x_array, a, t, m0=.975):
  """creates and returns numpy array of a constant density profile.
  
  Inputs:
  x_array: array of x values, where x for a given distance r is given by x=r/at. a= free parameter, t= time since start of collapse.
  a: free parameter
  t: age of cloud
  m0: free parameter taken to be 0.975 generally
  """ 
    
    return 1e5*np.ones(len(x_array))

def expand_nu_profile(x_array, a ,t):
  """creates and returns numpy array of a expanding cloud density profile.
  
  Inputs:
  x_array: array of x values, where x for a given distance r is given by x=r/at. a= free parameter to set velocity, t= time since start of collapse.
  a: free parameter to set velocity
  t: age of cloud
  """ 
    fact= 1e5/np.exp(x_array[-1]**2)
    
    return  fact*np.exp(x_array**2)

def dens_exp(x_array, a,t, nh0=1.4e3):
    """creates and returns numpy array of a exponential density profile.
  
  Inputs:
  x_array: array of x values, where x for a given distance r is given by x=r/at. a= isothermal speed of sound inside the photodissociative region , t= time since start of collapse.
  a: isothermal speed of sound inside the photodissociative region
  t: age of cloud
  nh0: density of inner photo-dissociative region
  """ 
    l= len(x_array)
    shell_dens= nh0*np.ones(l-1)
    v= v_exp(x_array,a,t)
    hii_dens= nh0*(v[-1]/v[1])**2
    
    return np.concatenate((np.array([hii_dens]),shell_dens))

"""Molecular density profiles:"""

def mol_dens_normal(nh, abnd):
  """creates and returns numpy array of a density of molecular tracer
  
  Inputs:
  nh- density profile array of H2/collissional partner
  abnd- abundance of molecular tracer wrt H2/collissional partner
  """ 
    return nh*abnd
    
def mol_dens_exp(nh, abnd):
  """creates and returns numpy array of a density of molecular tracer to be used for case of exponential density profile
  
  Inputs:
  nh- density profile array of H2/collissional partner
  abnd- abundance of molecular tracer wrt H2/collissional partner
  """ 
    return np.concatenate((np.array([0]),nh[1:]*abnd))

"""Temperature Profiles:"""

def temp_profile(r_array,t_0=28, r_0=1000*constants.au): 
  """creates and returns numpy array of temperature profile based on power law with slope -.4 as per Rowan-Robinson (1980).
  
  Inputs:
  r_array: array of r values, where r is distance from centre of collapse.
  t_0: temperature at a standard distance r_0 in K.
  r_0: distance from centre at which temperature is defined to be t_0 in m.
  """ 
    return t_0 * (r_array/r_0)**-.4

def const_t(r_array, t_0=28, r_0=1000*constants.au):
     """creates and returns numpy array of constant temperature profile 
  
  Inputs:
  r_array: array of r values, where r is distance from centre of collapse.
  t_0: temperature at a standard distance r_0 in K.
  r_0: distance from centre at which temperature is defined to be t_0 in m.
  """ 
    return t_0*np.ones(len(r_array))

def t_shell(r_array, t_0=28,r_0=1000*constants.au,t_in=1e4):
      """creates and returns numpy array of temperature profile for an expanding shell powered  by stellar core
  
  Inputs:
  r_array: array of r values, where r is distance from centre of collapse.
  t_0: temperature at a standard distance r_0 in K.
  r_0: distance from centre at which temperature is defined to be t_0 in m.
  t_in - temperature inside the photodissociative region
  """ 
    x= np.logspace(np.log10(t_in), np.log10(t_0),num= len(r_array)-1)
    
    return np.concatenate((np.array([0]),x))

def write_source_mdl(srcfilename="src.mdl", a=.24*constants.kilo, t=(10**5)*constants.year, molfile='hco+.dat', 
                     abnd_wrtH2= 2e-9, r_int=1.0272e13, r_out= 8000*constants.au, n_shells=16, spacing="logarithmically",
                     part2wrtH2=None, tdrat=1, terat=None, fwhm=2, gasdust=100, tkin_0=28, 
                     r_0=1000*constants.au, vfunc=shu_v_profile, nufunc= shu_nu_profile, tfunc=temp_profile,
                     molfunc=mol_dens_normal):
    

    """writes a .mdl file in working directory with necessary information about the model employed to be used by RATRAN in its calculations.
  Inputs:
 srcfilename: name of file to be created/over-written
 a: isothermal sound speed in m/s
 t: time since start of cloud collapse in s
 molfile: molecular data file of the molecule whose transitions are to be investigated
 abndwrtH2: abundance of molecule with respect to H2 (or whichever primary collision partner is being used)
 r_int: radius of the innermost shell in m
 r_out: radius of the outermost shell in m
 n_shells: number of shells to be created to model the source
 spacing: choose 'logarithmically' or 'linearly', will lead to logarithmically/linearly spaced shells accordingly
 part2wrtH2: if there's a secondary collision partner, mention its abundance wrt H2(primary collision partner). else leave as 'None'
 tdrat: temperature ratio of dust to gas. Leave as 1 for dust-gas completely coupled wrt temperature
 terat: in case of secondary collision partner, use to denote ratio of temperature of secondary partner(like electron) to gas. else leave as 'None'
 fwhm: spectral width in terms of velocity full width at half maxima. in m/s
 gasdust: to specify gas:dust ratio
 tkin_0: temperature at a standard distance r_0 in K.
 r_0: distance from centre at which temperature is defined to be t_0 in m.
 vfunc- velocity profile method to be used
 nufunc- density profile method to be used
 tfunc- temperature profile method to be used
 molfunc- molecular density profile method to be used
 """

    src=open(srcfilename, 'w')
    src.write('# Inside-out Collapsing Core (SHU 1977) \n')
    src.write("# Sound speed a="+ str(a/constants.kilo)+'km/s \n')
    src.write("# Age t= {:E} years \n".format(t/constants.year))
    src.write("# molecule: "+molfile[:-4]+ " abundance = {:E} wrt H2 \n".format(abnd_wrtH2))
    src.write("# Outer radius is {:g} AU, ".format(r_out/constants.au)+str(n_shells)+" shells, "+spacing+ " spaced \n")
    src.write("# Grid based velocity field \n")
    src.write("rmax={:E} \n".format(r_out))
    src.write("ncell={:g} \n".format(n_shells))
    src.write("tcmb=2.728 \n")
    
    id_array =np.array(range(1,n_shells+1))
    
    if spacing=="logarithmically":
        rb=np.logspace(np.log10(r_int), np.log10(r_out), n_shells)
    elif spacing== "linearly":
        rb=np.linspace(r_int,r_out, n_shells)
    else: print("spacing parameter is invalid. Pls enter 'logarithmically' or 'linearly'")
    ra= np.concatenate((np.array([0]), rb[:n_shells-1]))
    
    rx= (ra+rb)/2
    xra=ra/(a*t)
    xr= rx/(a*t)
    nh= nufunc(xra, a, t)
    nm= molfunc(nh=nh,abnd=abnd_wrtH2)
    tk= tfunc(rx,tkin_0, r_0)
    db= .6*fwhm
    vr= vfunc(xr, a,t)
    
    #make plots
    #Density
    plt.figure()
    plt.plot(ra,nh)
    plt.title('Density Profile')
    plt.xlabel('Radial distance (m)')
    plt.ylabel('Number Density of H2 (cm^-3)')
    
    #moldens
    plt.figure()
    plt.plot(ra,nm)
    plt.title('Density Profile')
    plt.xlabel('Radial distance (m)')
    plt.ylabel('Number Density of molecule (cm^-3)')
    
    #Temperature
    plt.figure()
    plt.plot(rx,tk)
    plt.title('Temperature Profile')
    plt.xlabel('Radial distance (m)')
    plt.ylabel('Kinetic Temperature (K)')
    
    #Velocity
    plt.figure()
    plt.plot(rx,vr)
    plt.title('Velocity Profile')
    plt.xlabel('Radial distance (m)')
    plt.ylabel('Infall Velocity (km/s)')
    
    columns=["id","ra","rb","nh","nm","tk","db","vr"]
    if part2wrtH2!=None: 
        columns.append("ne")
        ne= part2wrtH2*nh
    if tdrat!=None:
        columns.append("td")
        td= tk*tdrat
    if terat!=None: 
        columns.append("te")
        te= tk*terat
        
    src.write("columns=")
    for i in range(len(columns)-1):
        src.write(columns[i]+",")
    src.write(columns[-1]+" \n")    
    src.write("gas:dust={:g} \n".format(gasdust))
    src.write("@ \n")
    
    for id in id_array:
        
       if id<10:
           src.write("   "+str(id))
       else: src.write("  "+str(id))
       
       src.write("  {:E}".format(ra[id-1]))
       src.write("  {:E}".format(rb[id-1]))
       src.write("  {:E}".format(nh[id-1]))
       src.write("  {:E}".format(nm[id-1]))
       src.write("  {:E}".format(tk[id-1]))
       src.write("  {:E}".format(db))
       if vr[id-1]<0:
           src.write(" {:E}".format(vr[id-1]))
       else: src.write("  {:E}".format(vr[id-1]))
           
       if "ne" in columns:
           src.write("  {:E}".format(ne[id-1]))
       if "td" in columns:
           src.write("  {:E}".format(td[id-1]))
       if "te" in columns:  
           src.write("  {:E}".format(te[id-1]))
       
       src.write(" \n")

def write_amc_inp(amcfilename="amc.inp", srcfilename="src.mdl",outfilename="test.pop", molfile="hco+.dat", snr=20, nphot=1000,
                 ice="thin", coag='e5', tnorm=None, velo='grid', seed=1971, minpop=1.e-4, fixset=1.e-6, trace=False):
    """writes a .inp file in working directory with information to call to amc routine of RATRAN, and thereby calculate population levels. 
  
  Inputs:
  amcfilename: name of file to be created/over-written. (use .inp at the end)
  srcfilename: name of file that contains the source model information for RATRAN.
  outfilename: name of file to write the results of the amc routine to. (will be used as input for sky, use .pop at the end)
  molfile: molecular data file of the molecule whose transitions are to be investigated
  snr: required signal-to=noise ratio for convergence
  nphot: number of photons to use for first iteration of the RATRAN radiative transfer code
  ice:  'bare' or with 'thin' or 'thick' to describe ice mantles of the Ossenkopf & Henning dust models.
  coag: describes 'no' coagulation or with 1'e5', 1'e6', 1'e7', or 1'e8' years of growth acc to dust model.
  tnorm: is the blackbody temperature of the normalization used internally for the radiation field. If no value is given, tnorm=t_cmb or 2.735 K.
  velo: is either the file name (+path if not in current dir) of a user-provided velocity model (see $RATRAN/velocity/*.f for examples), or 'grid'. 
        'grid' means that the velocity vectors are read from the 'source' input model. 
  seed: random number seed
  minpop: minimum population to include in S/N calculation
  fixset: is the relative accuracy of the populations after the first stage (with rays fixed). The default value 1e-6 is usually OK; only very opaque problems may need lower values. 
  trace= If 'True', write history files to monitor convergence (default='False')      
  """ 
    amc=open(amcfilename,'w')
    
    amc.write("source="+srcfilename+" \n")
    amc.write("outfile="+outfilename+" \n")
    amc.write("molfile="+molfile+" \n")
    amc.write("snr="+str(snr)+" \n")
    amc.write("nphot="+str(nphot)+" \n")
    amc.write("kappa=jena,"+ice+","+coag+" \n")
    
    if tnorm!=None:
        amc.write("tnorm="+str(tnorm)+" \n")
    if velo!="grid":
        amc.write('velo='+velo+" \n")
        
    amc.write("seed="+str(seed)+" \n")
    
    if minpop!=1.e-4:
        amc.write("minpop={:e} \n".format(minpop))
    if fixset!=1.e-6:
        amc.write("fixset={:e} \n".format(fixset))
    if trace:
        amc.write("trace=on \n")
     
    amc.write("go \n")
    amc.write("q \n")

def run_amc(amcfilename="amc.inp"):
  """ runs amc routine on .inp file. Results in creation of .pop file with results of level populations
  
  Inputs:
  amcfilename: the .inp file containing the information to run amc, as created by write_amc_inp().
  """
    os.system("amc "+amcfilename)

def write_sky_inp(skyfilename="sky.inp",srcfilename="test.pop", outfilename="test_sky", trans=(1,3), pixno=128, pixsiz=0.5,
                  pixsetreg=32, pixlinsight=2, channo=50, chanwidth=0.1, dist=140, fg=None, central=None, units='K',
                  tnorm=None):
    """writes a .inp file in working directory with information to call to sky routine of RATRAN, and thereby calculate observed data. 
  
  Inputs:
  skyfilename: name of file to be created/over-written. (use .inp at the end)
  srcfilename: name of file with the results of the amc routine.
  outfilename: prefix of the .fits output file. eg if outfilename="test_sky", the result of the first transition will be written in test_sky_001.fits.
  trans: tuple of the different transition nos. whose results are required. eg for transition no 1 and 3 of molecular data file, (1,3) should be the tuple
  pixno: number of pixels in output per spatial dimension. eg pixno=128 creates 128x128 files.
  pixsiz: size of pixel in arc sec corresponding to real sky
  pixsetreg, pixlinsigth: optional. set the region pixsetreg=(numbers of pixels radius w.r.t. image center) over which to use multiple pixlinsight=(2 in the example) lines of sight to get the intensity in one pixel.
                          This is useful for sources with small details which need not be resolved in the image but need to be sampled for a proper answer. 
  channo: number of velocity channels to be sampled for spectra.
  chanwidth: width of each velocity channel in km/s.            
  dist: distance to source in parsecs.
  fg: file with table describing background. Default: 'None'
  central: central source radius [in arcsec] and blackbody temperature [in K]. Default: 'None'. 
  units: Default 'K'. Selects units of output images:            
        'K'        Kelvin       (good for line images)
        'Jypx'     Jy/pixel     (good for continuum images)
        'Wm2Hzsr'  W/m2/Hz/sr   (SI units)

  tnorm: is the blackbody temperature of the normalization used internally for the radiation field. If no value is given, tnorm=t_cmb or 2.735 K.
  """ 

    sky=open(skyfilename,'w')
    
    sky.write("source="+srcfilename+" \n")
    sky.write("format=fits \n")
    sky.write("outfile="+outfilename+" \n")
    
    sky.write("trans=")
    for x in trans[:-1]:
        sky.write(str(x)+",")
    sky.write(str(trans[-1])+" \n")

    sky.write("pix="+str(pixno)+","+str(pixsiz))
    if pixsetreg!=None:
        sky.write(','+str(pixsetreg))
    if pixlinsight!=None:
        sky.write(','+str(pixlinsight))
    sky.write(" \n")
     
    sky.write("chan="+str(channo)+","+str(chanwidth)+" \n")
    sky.write("distance={:g}. \n".format(dist))
    
    if fg!=None:
        sky.write("fg="+fg+" \n")
    if central!=None:
        sky.write("central="+central+" \n")
    
    sky.write("units="+units+" \n")
    
    if tnorm!=None:
        sky.write("tnorm="+str(tnorm)+" \n")
    
    sky.write("go \n")
    sky.write("q \n")

def run_sky(skyfilename="sky.inp"):
   """ runs sky routine on .inp file. Results in creation of .fits files with results.
  
  Inputs:
  skyfilename: the .inp file containing the information to run sky, as created by write_sky_inp().
  """
    os.system("sky "+skyfilename)

def read_fits(fitsfilename="test_sky", trans=(1,3)):
   """ reads .fits files containing results of RATRAN sky. returns a dict of transition-wise data cubes.
  
  Inputs:
  fitsfilename: the prefix for the .fits output file. eg if fitsfilename="test_sky", the result of the first transition will be found in test_sky_001.fits.
  trans: tuple of the different transition nos. whose results are required. eg for transition no 1 and 3 of molecular data file, (1,3) should be the tuple.
  """

    data={}
    for t in trans:
       if t<10: 
           name=fitsfilename+"_00"+str(t)+".fits"
       elif t<100:    
           name=fitsfilename+"_0"+str(t)+".fits"
       else:
           name=fitsfilename+"_"+str(t)+".fits"
           
       hdul=fits.open(name)
       
       data['transition no '+str(t)]=hdul[0].data
      
    return data

def run_RATRAN(a=.24*constants.kilo, t=(10**5)*constants.year, molfile="hco+.dat", abnd_wrtH2= 2e-9, r_int=1.0272e13, 
               r_out= 8000*constants.au, n_shells=16, spacing="logarithmically", part2wrtH2=None, tdrat=1, terat=None, 
               fwhm=2, gasdust=100, tkin_0=28, r_0=1000*constants.au, vfunc= shu_v_profile, nufunc=shu_nu_profile, 
               tfunc=temp_profile, molfunc=mol_dens_normal,
               snr=20, nphot=1000, ice="thin", coag='e5', tnorm=None, velo='grid', seed=1971, minpop=1.e-4, fixset=1.e-6, 
               trace=False,
               trans=(1,3), pixno=128, pixsiz=0.5, pixsetreg=32, pixlinsight=2, channo=50, chanwidth=0.1, dist=140, fg=None, 
               central=None, units='K'):
    """Goes through the entire process of writing source/input files, running amc and sky, and reading .fits outputs. Returns dict of transition-wise data cubes.
  
  Inputs:
  
  First set(for source model):

    a: isothermal sound speed in m/s
    t: time since start of cloud collapse in s
    molfile: molecular data file of the molecule whose transitions are to be investigated
    abndwrtH2: abundance of molecule with respect to H2 (or whichever primary collision partner is being used)
    r_int: radius of the innermost shell in m
    r_out: radius of the outermost shell in m
    n_shells: number of shells to be created to model the source
    spacing: choose 'logarithmically' or 'linearly', will lead to logarithmically/linearly spaced shells accordingly
    part2wrtH2: if there's a secondary collision partner, mention its abundance wrt H2(primary collision partner). else leave as 'None'
    tdrat: temperature ratio of dust to gas. Leave as 1 for dust-gas completely coupled wrt temperature
    terat: in case of secondary collision partner, use to denote ratio of temperature of secondary partner(like electron) to gas. else leave as 'None'
    fwhm: spectral width in terms of velocity full width at half maxima. in m/s
    gasdust: to specify gas:dust ratio
    tkin_0: temperature at a standard distance r_0 in K.
    r_0: distance from centre at which temperature is defined to be t_0 in m.

  Second set( for amc input file):

  snr: required signal-to=noise ratio for convergence
  nphot: number of photons to use for first iteration of the RATRAN radiative transfer code
  ice:  'bare' or with 'thin' or 'thick' to describe ice mantles of the Ossenkopf & Henning dust models.
  coag: describes 'no' coagulation or with 1'e5', 1'e6', 1'e7', or 1'e8' years of growth acc to dust model.
  tnorm: is the blackbody temperature of the normalization used internally for the radiation field. If no value is given, tnorm=t_cmb or 2.735 K.
  velo: is either the file name (+path if not in current dir) of a user-provided velocity model (see $RATRAN/velocity/*.f for examples), or 'grid'. 
        'grid' means that the velocity vectors are read from the 'source' input model. 
  seed: random number seed
  minpop: minimum population to include in S/N calculation
  fixset: is the relative accuracy of the populations after the first stage (with rays fixed). The default value 1e-6 is usually OK; only very opaque problems may need lower values. 
  trace= If 'True', write history files to monitor convergence (default='False')  

  Third set( for sky input file):    

  trans: tuple of the different transition nos. whose results are required. eg for transition no 1 and 3 of molecular data file, (1,3) should be the tuple
  pixno: number of pixels in output per spatial dimension. eg pixno=128 creates 128x128 files.
  pixsiz: size of pixel in arc sec corresponding to real sky
  pixsetreg, pixlinsigth: optional. set the region pixsetreg=(numbers of pixels radius w.r.t. image center) over which to use multiple pixlinsight=(2 in the example) lines of sight to get the intensity in one pixel.
                          This is useful for sources with small details which need not be resolved in the image but need to be sampled for a proper answer. 
  channo: number of velocity channels to be sampled for spectra.
  chanwidth: width of each velocity channel in km/s.            
  dist: distance to source in parsecs.
  fg: file with table describing background. Default: 'None'
  central: central source radius [in arcsec] and blackbody temperature [in K]. Default: 'None'. 
  units: Default 'K'. Selects units of output images:            
        'K'        Kelvin       (good for line images)
        'Jypx'     Jy/pixel     (good for continuum images)
        'Wm2Hzsr'  W/m2/Hz/sr   (SI units)
  """ 
    
    
    start=time.time()
    write_source_mdl(a=a,t=t,molfile=molfile,abnd_wrtH2=abnd_wrtH2, r_int=r_int, r_out=r_out, n_shells=n_shells, 
                     spacing=spacing, part2wrtH2=part2wrtH2, tdrat=tdrat, terat=terat, fwhm=fwhm, gasdust=gasdust, 
                     tkin_0=tkin_0, r_0=r_0, vfunc=vfunc, nufunc=nufunc, tfunc=tfunc, molfunc=molfunc)
    write_amc_inp(molfile=molfile,snr=snr, nphot=nphot, ice=ice, coag=coag, tnorm=tnorm, velo=velo, seed=seed, minpop=minpop,
                  fixset=fixset, trace=trace)
    write_sky_inp(trans=trans, pixno=pixno,pixsiz=pixsiz,pixsetreg=pixsetreg,pixlinsight=pixlinsight,channo=channo,
                  chanwidth=chanwidth,dist=dist,fg=fg,central=central, units=units,tnorm=tnorm)
    
    run_amc()
    run_sky()
    
    data= read_fits(trans=trans)
    
    end=time.time()
    dure = end - start
    print ("Run time = ",dure, "seconds")
    
    return data

def show_fits_images(data_dict, cmaps='gist_yarg', vchanno= 25,trans=(1,3), pixsiz=0.5):
  """
  Displays a representative map of the emitting cloud, for a particular velocity channel.

  Inputs:

  data_dict: dictionary of transition-wise data as obtained from run_RATRAN()
  cmaps: color coding of map. Default='gist_yarg'
  vchanno: velocity channel number. If total number channels are 2n+1, then n will be the channel number representing 0 velocity.
  trans: tuple of transitions for which the images are required. Warning: only enter values for which data RATRAN has been solved. 
  pixsiz: number of arc secs of actual sky represented by one pixel of image. Default: 0.5
  """
     
    for t in trans:
        a= data_dict['transition no '+str(t)]
        pixno= len(a[0,0,:])
        
        n=(pixno+1)*pixsiz/2
        extent=(-n,n,-n,n)
        
        plt.figure()
        plt.title('Transition no '+str(t))
        plt.imshow(a[vchanno-1], cmap=cmaps, extent=extent)
        plt.xlabel('X-position (arc sec)')
        plt.ylabel('Y-position (arc sec)')
        plt.colorbar()

def plot_spectra(data_dict, coord=(63,63), trans=(1,3), chanwidth=0.1):
"""
  Plots Intensity vs velocity spectra for a given position in the sky.

  Inputs:

  data_dict: dictionary of transition-wise data as obtained from run_RATRAN()
  coord: 2-tuple of pixel no. of x and y values of position in sky. If total number of pixels along any axis are 2n+1, then n-1 will be the required value for the centre position.
  trans: tuple of transitions for which the spectra are required. Warning: only enter values for which data RATRAN has been solved. 
  chanwidth: width of each velocity channel (in km/s)
  """

     x,y=coord
     for t in trans:
        a= data_dict['transition no '+str(t)]
        spec= a[:,x,y]
        no=len(spec)
        if no%2==0:
            prof=chanwidth*np.array(range(round(-no/2), round((no/2))))
        else: prof=chanwidth*np.array(range(round((-no/2)+.5), round((no/2)+.5)))
        
        plt.figure()
       
        plt.xlabel('Velocity (km/s)')
        plt.ylabel('Line flux (K)')
        plt.title('Transition no '+str(t))
        plt.plot(prof, spec)

def pos_vel_slicex(data_dict,y=63, trans=(1,3), pixsiz=0.5, chanwidth=0.1):
"""
  Plots position velocity diagram in the form of a contour for a given y value.

  Inputs:

  data_dict: dictionary of transition-wise data as obtained from run_RATRAN()
  y: pixel no. of y value of position in sky. If total number of pixels along any axis are 2n+1, then n-1 will be the required value for the centre position.
  trans: tuple of transitions for which the spectra are required. Warning: only enter values for which data RATRAN has been solved. 
  pixsiz: number of arc secs of actual sky represented by one pixel of image. Default: 0.5
  chanwidth: width of each velocity channel (in km/s). Default: 0.1
  """
    
    for t in trans:
        a= data_dict['transition no '+str(t)]
        
        no=len(a[:,0,y])
        if no%2==0:
            vel=chanwidth*np.array(range(round(-no/2), round((no/2))))
        else: vel=chanwidth*np.array(range(round((-no/2)+.5), round((no/2)+.5)))
        
        n=len(a[0,:,y])
        if no%2==0:
            arcx=pixsiz*np.array(range(round(-n/2), round((n/2))))
        else: arcx=pixsiz*np.array(range(round((-n/2)+.5), round((n/2)+.5)))
       
        
        plt.figure()
        plt.contour(arcx,vel,a[:,:,y])
        plt.colorbar()
        plt.xlabel('X-position (arc sec)')
        plt.ylabel('Velocity (km/s)')
        plt.title('Transition no '+str(t))

def channel_maps(data_dict, cmaps='hot', Nr=3, Nc=3, vchans=(46,41,36,31,26,21,16,11,6), trans=(1,3), pixsiz=.5, chanwidth=.1):
"""
  Plots channels maps corresponding to different velocity channels of the data. Note: Nr*Nc should be equal to the len of vchans.

  Inputs:

  data_dict: dictionary of transition-wise data as obtained from run_RATRAN()
  cmaps: color coding of map. Default='hot'
  Nr: number of rows of subplots (each subplot is a channel map for a specific velocity)
  Nc: number of channels of subplots (each subplot is a channel map for a specific velocity)
  vchans:tuple of velocity channel numbers for which chanmaps will be generated. If total number channels in data are 2n+1, then n will be the channel number representing 0 velocity.
  trans: tuple of transitions for which the spectra are required. Warning: only enter values for which data RATRAN has been solved. 
  pixsiz: number of arc secs of actual sky represented by one pixel of image. Default: 0.5
  chanwidth: width of each velocity channel (in km/s). Default: 0.1
  """    
    for t in trans:
        a= data_dict['transition no '+str(t)]
        n= len(a[:,0,0])
        if n%2==0:
            v_arr= (np.array((vchans))-(n/2)-1)*chanwidth
        else:
            v_arr= (np.array((vchans))-(n+1/2))*chanwidth
        
        pixno= len(a[0,0,:])
        
        n=(pixno+1)*pixsiz/2
        extent=(-n,n,-n,n)

        f, ax = plt.subplots(Nr, Nc, True, True, figsize=(16,12))
        
        f.suptitle('Channel maps '+'transition no '+str(t), fontsize='xx-large')
     
        images=[]
        it=0
        for i in range(Nr):
            for j in range(Nc):
                images.append(ax[i,j].imshow(a[vchans[it]-1,:,:], cmap=cmaps, extent=extent))
                ax[i,j].set_title(str(v_arr[it]) + " km/s", size='xx-large')
                it+=1
                if it==len(vchans):
                    break
        
        vmin = min(image.get_array().min() for image in images)
        vmax = max(image.get_array().max() for image in images)
        norm = colors.Normalize(vmin=vmin, vmax=vmax)
        for im in images:
           im.set_norm(norm)
         
        cax = plt.axes([0.80, 0.1, 0.05, 0.85])    
        f.colorbar(images[0], ax=ax, orientation='vertical', cax=cax, fraction=.1)    

        def update(changed_image):
            for im in images:
                if (changed_image.get_cmap() != im.get_cmap()
                or changed_image.get_clim() != im.get_clim()):
                    im.set_cmap(changed_image.get_cmap())
                    im.set_clim(changed_image.get_clim())


        for im in images:
            im.callbacksSM.connect('changed', update)

        plt.subplots_adjust(bottom=0.1, right=0.85, top=.93, hspace=.15, wspace=-.4)
        
        plt.show()

def pos_v_arbit(data_dict,x1=(0,0), x2=(127,127), trans=(1,3), chanwidth=.1, pixsiz=.5):
"""
  Plots position velocity diagram in the form of a contour on line from start point x1 to end point x2, on map. 

  Inputs:

  data_dict: dictionary of transition-wise data as obtained from run_RATRAN()
  x1: tuple of x and y coordinates from where line starts. (pixel nos. are required)
  x2: tuple of x and y coordinates where line stops. (pixel nos. are required)
  trans: tuple of transitions for which the spectra are required. Warning: only enter values for which data RATRAN has been solved. 
  pixsiz: number of arc secs of actual sky represented by one pixel of image. Default: 0.5
  chanwidth: width of each velocity channel (in km/s). Default: 0.1
  """
    
    dist=np.around(np.sqrt( (x2[0]-x1[0])**2 + (x2[1]-x1[1])**2)).astype(int)
    
    x_arr= np.around(np.linspace(x1[0],x2[0],dist)).astype(int)
    y_arr= np.around(np.linspace(x1[1],x2[1],dist)).astype(int)
    
    for t in trans:
         a= data_dict['transition no '+str(t)]
         
         stack=[]
         for i in range(dist):
             stack.append(a[:,x_arr[i], y_arr[i]])
             
         k= np.column_stack(stack)
         
         no=len(a[:,0,0])
         if no%2==0:
             vel=chanwidth*np.array(range(round(-no/2), round((no/2))))
         else: vel=chanwidth*np.array(range(round((-no/2)+.5), round((no/2)+.5)))
         
         arcx= pixsiz*np.array(range(dist)) 
         
         plt.figure() 
         plt.contour(arcx, vel, k)
         plt.colorbar()
         plt.xlabel('Displacement along slice (arc sec)')
         plt.ylabel('Velocity (km/s)')
         plt.title('Transition no '+str(t))