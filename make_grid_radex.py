# -*- coding: utf-8 -*-
"""make_grid_radex

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/13W3OgO_5owwQHdRakR2sHVsPOFLaxl6N
"""

from pythonradex import nebula,helpers, LAMDA_file
from scipy import constants
import numpy as np
import copy

def calc_flux(d_observer, source_radius, data_filepath, geometry='uniform sphere', ext_background=helpers.CMB_background, Tkin=150, 
                     coll_partner_densities={'H2':100/constants.centi**3}, Ntot= 1e15/constants.centi**2, line_profile= 'square', width_v= 2*constants.kilo):
    """ 
    returns a list of calculated fluxes in W/m^2 of various transitions corresponding to the molecule in data file (eg CO) for the given conditions of interstellar cloud.
    Inputs:
    d_observer-distance between observer and source 
    source_radius- radius of source
    data_filepath- filepath containing data about the molecule and its various transitions from LAMDA database http://www.strw.leidenuniv.nl/~moldata/
    geometry- geometry of cloud structure. “uniform sphere”, “uniform sphere RADEX”, “face-on uniform slab” and “uniform shock slab RADEX” are the available options
    ext_background- external radiation that forms the background of the cloud structure (default is CMB)
    Tkin- average kinetic temperature of the cloud in Kelvin
    coll_partner_densities- dict containing info about collision partners to molecule and their respective number densities in m^-3. must be present in molecular data file
        (eg CS molecule supports only H2 as collisional partner) pythonradex supports “H2”, “para-H2”, “ortho-H2”, “e”, “H”, “He”, “H+” as collision partners
    Ntot- total column density in m^-2 
    line profile- type of line profile. available are 'Gaussian' and 'square'   
    width_v- width of the line in [m/s]. For Gaussian, this is the FWHM.                  
    """
    example_nebula = nebula.Nebula(
                        data_filepath=data_filepath,geometry=geometry,
                        ext_background=ext_background,Tkin=Tkin,
                        coll_partner_densities=coll_partner_densities,
                        Ntot=Ntot,line_profile=line_profile,width_v=width_v) 
    #creates .Nebula object with given properties as a model of the cloud
    example_nebula.solve_radiative_transfer()     
    #solves radiative transfer equations for given nebula object 

    solid_angle = source_radius**2*np.pi/d_observer**2                        
    #calculates solid angle of source subtended on observer
    example_nebula.compute_line_fluxes(solid_angle=solid_angle)               
    #computes observed line fluxes of radiative transitions of molecule from given nebula of given size at given distance

    return example_nebula.obs_line_fluxes                                
    #returns the list containing observed line spectra. size= no of radiative transitions of molecule



def make_grid_radex(data_filepath,  d_observer, source_radius, Tkin_low=10, Tkin_high=300, Tkin_steps=10, Ntot_low=1e-2/constants.centi**2, 
                    Ntot_high=1e15/constants.centi**2, Ntot_steps=15, coll_densities_low={'H2':10/constants.centi**3}, coll_densities_high={'H2':1e10/constants.centi**3}, coll_density_steps=10, geometry= 'uniform sphere', ext_background= helpers.CMB_background, line_profile= "square", width_v= 2*constants.kilo):
    """ 
    makes a grid of calculated line fluxes by iterating over kinetic temperature, cloud total density, and molecular column densities.
    returns a tuple (numpy array of kinetic temperatures, numpy array of cloud densities,  dict of collision partner as key and numpy arrays of its column densities as values, grid of calculated fluxes for each transition which can be accessed as g[Tkin_no][Ntot_no][column density_no][tranisition_no] in case of one collision partner)
    Supports upto 2 collision partners in one call.
    
    Inputs:
    data_filepath- filepath containing data about the molecule and its various transitions from LAMDA database http://www.strw.leidenuniv.nl/~moldata/
    d_observer-distance between observer and source 
    source_radius- radius of source

    Tkin_low- lower bound of the range of average kinetic temperature of the cloud in Kelvin to be iterated over
    Tkin_high- upper bound of the range of average kinetic temperature of the cloud in Kelvin to be iterated over
    Tkin_steps- number of values of Tkin to iterate over

    Ntot_low- lower bound of total column density in m^-2  to be iterated over
    Ntot_high- upper bound of total column density in m^-2  to be iterated over
    Ntot_steps- number of values of Ntot to iterate over

    coll_partner_densities- dict containing info about collision partners to molecule and their respective number densities in m^-3. must be present in molecular data file
                            (eg CS molecule supports only H2 as collisional partner) pythonradex supports “H2”, “para-H2”, “ortho-H2”, “e”, “H”, “He”, “H+” as collision partners
          coll_densities_low- dict with lower bound of number density of collision partner to be iterated over
          coll_densities_upper- dict with upper bound of number density of collision partner to be iterated over
          coll_density_steps- number of values of coll_partner_densities to iterate over

    geometry- geometry of cloud structure. “uniform sphere”, “uniform sphere RADEX”, “face-on uniform slab” and “uniform shock slab RADEX” are the available options
    ext_background- external radiation that forms the background of the cloud structure (default is CMB)
    line profile- type of line profile. available are 'Gaussian' and 'square'   
    width_v- width of the line in [m/s]. For Gaussian, this is the FWHM.    
        """
    data = LAMDA_file.read(data_filepath)
    no_transitions= len(data['radiative transitions']) #reads LAMDA file to find out no. of radiative transitions of molecule
    
    if Tkin_low > Tkin_high:
        return "Given lower temperature is higher than upper temperature. Please order temperatures correctly."
    if Tkin_high >= 3000:
        return "Given upper temperature is too high for pythonradex. Please enter a temperature between 2K-3000K"
    if Tkin_low < 10:
        return "Given lower temperature is too low for pythonradex. Please enter a temperature between 2K-3000K"
    #checks if given temperature is in range for pythonradex
    
    if coll_densities_high.keys() != coll_densities_low.keys():
        return "Collision partners given in lower bounds and upper bounds dictionary do not match"  
     #checks if given dictionaries contain the same collision partners
    for coll_partner in coll_densities_low.keys():
        if coll_partner not in data['collisional transitions'].keys():
            return "Collission partner "+ coll_partner+ " not in molecular data file"             
     #checks if given collision partners are in lamda data file for the molecule
    
    Tkin_array= np.logspace(np.log10(Tkin_low), np.log10(Tkin_high), num=Tkin_steps)             
    #creates logarithmically spaced array of Tkin to be iterated over
    Ntot_array= np.logspace(np.log10(Ntot_low), np.log10(Ntot_high), num= Ntot_steps)           
    #creates logarithmically spaced array of Ntot to be iterated over
      
    
    if len(coll_densities_high)==1:   
        grid= np.empty((Tkin_steps,Ntot_steps, coll_density_steps,no_transitions))      
        #creates empty grid with required dimensions to be filled in for each condition of Tkin, Ntot, coll density
      
        for coll_partner in coll_densities_low.keys():
            key= coll_partner
        coll_partner_array= np.logspace(np.log10(coll_densities_low[key]),
                                          np.log10(coll_densities_high[key]),
                                          num=coll_density_steps)                                 
        #creates array of coll_partner densities to be iterated over
        
        coll_partner_dict= {key : coll_partner_array}                                                
        #creates coll_partner_dict for output
        coll_partner_densities=  copy.deepcopy(coll_densities_low)                                              
        #initializes coll_partner_densities dict object
        
        print("No of grid points to be calculated=" + str(Tkin_steps*Ntot_steps*coll_density_steps))
        iteration= 0 
        #for displaying progress of computation
        
        for Tkin_no in range(len(Tkin_array)):
            for Ntot_no in range(len(Ntot_array)):
                for density_no in range(len(coll_partner_array)):
                    
                    coll_partner_densities[key]= coll_partner_array[density_no]                   
                    #modifies coll_partner_densities dict with the updated value of density of collision partner
                    
                    grid[Tkin_no,Ntot_no,density_no]= calc_flux(data_filepath=data_filepath, geometry=geometry, ext_background=ext_background, Tkin=Tkin_array[Tkin_no], coll_partner_densities= coll_partner_densities, Ntot= Ntot_array[Ntot_no],line_profile=line_profile, width_v=width_v, d_observer=d_observer, source_radius=source_radius)
                  
                #populates grid by inserting list of observed line fluxes at given conditions obtained from calling calc_intensities function at grid[Tkin_no][Ntot_no][density_no]
                   
                    iteration +=1
                    print("Grid points calculated=" + str(iteration))
                    #displays progress of computation
                   
        return (Tkin_array, Ntot_array, coll_partner_dict, grid)     #returns required tuple of values
  
    elif len(coll_densities_high)==2:   
        grid= np.empty((Tkin_steps,Ntot_steps, coll_density_steps,coll_density_steps,no_transitions))      
        # creates empty grid with required dimensions to be filled in for each condition of Tkin, Ntot, coll density
      
        coll_partner_dict = copy.deepcopy(coll_densities_low)
        for key in coll_densities_low.keys():
            coll_partner_dict[key]= np.logspace(np.log10(coll_densities_low[key]),
                                          np.log10(coll_densities_high[key]),
                                          num=coll_density_steps)
        #creates coll_partner_dict which will be used for computation and output    
        coll_partner_densities= copy.deepcopy(coll_densities_low)  
        #initializes coll_partner_densities which will be updated and fed into calc_spectra func
      
        print("No of grid points to be calculated=" + str(Tkin_steps*Ntot_steps*coll_density_steps*coll_density_steps))
        iteration= 0 
        #for displaying progress of computation
        
        for Tkin_no in range(len(Tkin_array)):
            for Ntot_no in range(len(Ntot_array)):
                for density_1 in range(coll_density_steps):
                    for density_2 in range(coll_density_steps):
                      
                        i=1
                        for keys in coll_partner_dict.keys():
                          
                            if i==1:
                                coll_partner_densities[keys]= coll_partner_dict[keys][density_1]
                                i+=1
                            else: coll_partner_densities[keys]= coll_partner_dict[keys][density_2]
                        #updates coll_partner_densities for given iteration        
                          
                        grid[Tkin_no,Ntot_no,density_1,density_2]= calc_flux(data_filepath=data_filepath, geometry=geometry, ext_background=ext_background, Tkin=Tkin_array[Tkin_no], coll_partner_densities= coll_partner_densities, Ntot= Ntot_array[Ntot_no],line_profile=line_profile,width_v=width_v, d_observer=d_observer, source_radius=source_radius)
                        #populates grid by inserting list of observed line flux at given conditions obtained from calling calc_intensities function at grid[Tkin_no][Ntot_no][density_no]
                        
                        iteration+=1
                        print("Grid points calculated=" + str(iteration))
                        #displays progress of computation
                        
        return (Tkin_array, Ntot_array, coll_partner_dict, grid)     
        #returns required tuple of values